package com.duedil.mesos.java;

import com.google.protobuf.ByteString;

import org.apache.mesos.v1.Protos.AgentID;
import org.apache.mesos.v1.Protos.ExecutorID;
import org.apache.mesos.v1.Protos.FrameworkID;
import org.apache.mesos.v1.Protos.MasterInfo;
import org.apache.mesos.v1.Protos.Offer;
import org.apache.mesos.v1.Protos.OfferID;
import org.apache.mesos.v1.Protos.TaskStatus;

import java.util.List;

/**
 * Interface for Mesos schedulers. Users' schedulers should implement this class to get default
 * implementations of methods they don't override.
 */
public interface Scheduler {

    /**
     * Invoked when the scheduler successfully registers with a Mesos master. It is called with
     * the frameworkId, a unique ID generated by the master, and the masterInfo which is
     * information about the master itself.
     */
    void registered(SchedulerDriver driver, FrameworkID frameworkId, MasterInfo masterInfo);

    /**
     * Invoked when the scheduler re-registers with a newly elected Mesos master. This is only
     * called when the scheduler has previously been registered. masterInfo contains information
     * about the newly elected master.
     */
    void reregistered(SchedulerDriver driver, MasterInfo masterInfo);

    /**
     * Invoked when the scheduler becomes disconnected from the master, e.g. the master fails
     * and another is taking over.
     */
    void disconnected(SchedulerDriver driver);

    /**
     * Invoked when resources have been offered to this framework. A single offer will only
     * contain resources from a single slave.  Resources associated with an offer will not
     * be re-offered to _this_ framework until either (a) this framework has rejected those
     * resources (see SchedulerDriver.launchTasks) or (b) those resources have been rescinded
     * (see Scheduler.offerRescinded).  Note that resources may be concurrently offered to√ò
     * more than one framework at a time (depending on the allocator being used).  In that
     * case, the first framework to launch tasks using those resources will be able to use
     * them while the other frameworks will have those resources rescinded (or if a framework
     * has already launched tasks with those resources then those tasks will fail with a
     * TASK_LOST status and a message saying as much).
     */
    void resourceOffers(SchedulerDriver driver, List<Offer> offers);

    /**
     * Invoked when an offer is no longer valid (e.g., the slave was lost or another framework
     * used resources in the offer.) If for whatever reason an offer is never rescinded
     * (e.g., dropped message, failing over framework, etc.), a framework that attempts to
     * launch tasks using an invalid offer will receive TASK_LOST status updates for those tasks
     * (see Scheduler.resourceOffers).
     */
    void offerRescinded(SchedulerDriver driver, OfferID offerId);

    /**
     * Invoked when the status of a task has changed (e.g., a slave is lost and so the task is
     * lost, a task finishes and an executor sends a status update saying so, etc). If implicit
     * acknowledgements are being used, then returning from this callback _acknowledges_ receipt
     * of this status update! If for whatever reason the scheduler aborts during this callback
     * (or the process exits) another status update will be delivered (note, however, that this
     * is currently not true if the slave sending the status update is lost/fails during that
     * time). If explicit acknowledgements are in use, the scheduler must acknowledge this
     * status on the driver.
     */
    void statusUpdate(SchedulerDriver driver, TaskStatus status);

    /**
     * Invoked when an executor sends a message. These messages are best effort; do not expect a
     * framework message to be retransmitted in any reliable fashion.
     */
    void frameworkMessage(SchedulerDriver driver, ExecutorID executorId, AgentID agentId, ByteString message);

    /**
     * Invoked when a agent has been determined unreachable (e.g., machine failure, network
     * partition.) Most frameworks will need to reschedule any tasks launched on this agent
     * on a new agent.
     *
     * NOTE: This callback is not reliably delivered. If a host or network failure causes
     * messages between the master and the scheduler to be dropped, this callback may not be
     * invoked.
     */
    void agentLost(SchedulerDriver driver, AgentID agentId);

    /**
     * Invoked when an executor has exited/terminated. Note that any tasks running will have
     * TASK_LOST status updates automatically generated.
     *
     * NOTE: This callback is not reliably delivered. If a host or network failure causes
     * messages between the master and the scheduler to be dropped, this callback may not
     * be invoked.
     */
    void executorLost(SchedulerDriver driver, ExecutorID executorId, AgentID agentId, int status);

    /**
     * Invoked when there is an unrecoverable error in the scheduler or scheduler driver.
     * The driver will be aborted BEFORE invoking this callback.
     */
    void error(SchedulerDriver driver, String message);
}
